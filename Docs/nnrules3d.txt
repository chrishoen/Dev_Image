# DNW DNN DNE    CNW CNN CNE    UNW UNN UNE
# DWW DXX DEE    CWW CXX CEE    UWW UXX UEE
# DSW DSS DSE    CSW CSS CSE    USW USS USE
   
# copy the input image to the output image.
output_image = input_image_c.clone()

# loop through all of the pixels in the input image
# to filter the high pixels.
for xpixel in input_image_c:
   if input_image_c.at(xpixel) != 0
      filter_high_pixel(xpixel)
      
# filter a high pixel based on nearest neighbor rules.
def filter_high_pixel(x):
   # extract nearest neighbors.
   # NW NN NE
   # WW XX EE
   # SW SS SE
   
   CNW = input_image_c(x.row-1,x.col-1) != 0
   CNN = input_image_c(x.row-1,x.col  ) != 0
   CNE = input_image_c(x.row-1,x.col+1) != 0
   CWW = input_image_c(x.row  ,x.col-1) != 0
   CXX = input_image_c(x.row  ,x.col  ) != 0
   CEE = input_image_c(x.row  ,x.col+1) != 0
   CSW = input_image_c(x.row+1,x.col-1) != 0
   CDU = input_image_c(x.row+1,x.col  ) != 0
   CSE = input_image_c(x.row+1,x.col+1) != 0

   # count the number of nearest neighbors that are occupied.
   DNN_sum = DNW + DNN + DNE + DWW + DEE + DSW + DSS + DSE
   CNN_sum = CNW + CNN + CNE + CWW + CEE + CSW + CSS + CSE
   UNN_sum = UNW + UNN + UNE + UWW + UEE + USW + USS + USE
   
   # rule 1.
   if (CNN and CSS and CEE and CWW and UXX and DXX):
      return
      
   # rule 2.
   if (CNN and CSS and CEE and CWW):
      return 

   # rule 3.
   if (UXX and DXX) and ((CNN and CSS) or (CEE and CWW)):
      return 

   # rule 4.
   if (UXX and DXX) and (CNN_sum <= 3)):
      output_image.at(x) = parms.hc1
      return 

   # rule 5.  
   if (UXX and DXX):
      output_image.at(x) = parms.hc2
      return

   # rule 6.
   if (CNN_sum <= 3)):
      output_image.at(x) = parms.hc1
      return 

   # rule 7.
   output_image.at(x) = parms.hc2
   return
